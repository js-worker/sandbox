<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JS Worker Sandbox E2E Test</title>
  </head>
  <body>
    <script>
      class BrowserWorkerSandbox {
        worker;
        script;
        eventListeners;

        constructor(sandboxOptions = {}) {
          const { script, extend } = sandboxOptions;
          this.eventListeners = new Map();
          this.script = this.initScript(script);
          const workerCode = `
      ${this.script}

      class FetchEvent {
        constructor(request) {
          this.request = request;
          this.response = null;
        }

        respondWith(response) {
          this.response = response;
        }

        waitUntil(promise) {
          promise.then(() => {}).catch(console.error);
        }

        passThroughOnException() {}
      }

      self.addEventListener = (type, listener) => {
        self.addEventListener(type, listener);
      };

      self.onmessage = async (event) => {
        if (event.data.type === 'fetch') {
          const fetchEvent = new FetchEvent(event.data.request);
          self.dispatchEvent(new CustomEvent('fetch', { detail: fetchEvent }));
          if (fetchEvent.response) {
            const responseData = await serializeResponse(fetchEvent.response);
            self.postMessage({ type: 'fetchResponse', response: responseData });
          }
        }
      };

      async function serializeResponse(response) {
        const { status, statusText, headers } = response;
        const body = await response.text();
        return { status, statusText, headers: Object.fromEntries(headers), body };
      }
    `;
          const blob = new Blob([workerCode], {
            type: 'application/javascript',
          });
          this.worker = new Worker(URL.createObjectURL(blob));
          this.worker.onmessage = (event) => {
            if (event.data.type === 'fetchResponse') {
              const listeners = this.eventListeners.get('fetch') || new Set();
              const response = this.deserializeResponse(event.data.response);
              listeners.forEach((listener) => listener(response));
            }
          };
          if (extend) {
            const extendedContext = extend({});
            Object.keys(extendedContext).forEach((key) => {
              this.worker.postMessage({
                type: 'extend',
                key,
                value: extendedContext[key],
              });
            });
          }
        }
        initScript(script) {
          if (script && typeof script === 'string' && script.length > 0) {
            return script;
          }
          
          return '';
        }
        async dispatchFetch(url, requestInit) {
          return new Promise((resolve) => {
            const fetchListener = (response) => {
              resolve(response);
              const listeners = this.eventListeners.get('fetch') || new Set();
              listeners.delete(fetchListener);
            };
            const listeners = this.eventListeners.get('fetch') || new Set();
            listeners.add(fetchListener);
            this.eventListeners.set('fetch', listeners);
            this.worker.postMessage({
              type: 'fetch',
              request: { url, ...requestInit },
            });
          });
        }
        deserializeResponse(responseData) {
          const { status, statusText, headers, body } = responseData;
          return new Response(body, { status, statusText, headers });
        }
        dispose() {
          this.worker.terminate();
          this.eventListeners.clear();
        }
      }

      const ws = new BrowserWorkerSandbox({
        script: `addEventListener("fetch", (event) => {
  console.log(event.request.url);
  event.respondWith(new Response("Hello WorkerSandbox!"));
});`,
      });

      ws.dispatchFetch("http://localhost:8000/").then((res) => {
        res.text().then(text => console.log(text));
      });
    </script>
  </body>
</html>